+++
title = 'tidyr'
subtitle = "シンプルなデータ変形ツール"
tags = ["r", "tidyverse"]
[menu.main]
  parent = "rstats"
  weight = -74
+++

```{r, setup-r}
#| file: "setup.R"
#| cache: false
#| echo: false
#| results: "hide"
```

```{r, setup-local}
#| cache: false
#| echo: false
withr::local_package("tidyr")
```

<a href="https://tidyr.tidyverse.org/">
<img src="/_img/hex-stickers/tidyr.webp" align="right" width="120" height="139">
</a>

data.frameを縦長・横広・入れ子に変形・整形するためのツール。
[dplyr]({{< relref "dplyr.md" >}}) や [purrr]({{< relref "purrr.md" >}})
と一緒に使うとよい。
[reshape2]({{< relref "reshape2.md" >}}) を置き換えるべく再設計された改良版。

[tidyverse](https://tidyverse.tidyverse.org/) に含まれているので、
`install.packages("tidyverse")` で一括インストール、
`library(tidyverse)` で一括ロード。

-   <https://r4ds.hadley.nz/data-tidy.html>
-   <https://github.com/tidyverse/tidyr>
-   `vignette("tidy-data")`
-   `demo(package = "tidyr")`
-   https://speakerdeck.com/yutannihilation/tidyr-pivot

パイプ演算子 `|>` については[dplyr]({{< relref "dplyr.md" >}})を参照。


## Pivoting: 縦長 ↔ 横広

https://tidyr.tidyverse.org/articles/pivot.html

### `tidyr::pivot_longer()` で縦長にする

複数列のmatrix的にまたがっていた値を1列にまとめ、元の列名をその横に添えることで、
data.frameを横広(wide-format)から縦長(long-format)に変形する。
`reshape2::melt()`, `tidyr::gather()` の改良版。

`tidyr::pivot_longer(data, cols, names_to = "name", ..., values_to = "value", ...)`

`cols`
: 動かしたい値が含まれている列。
  コロンで範囲指定、文字列、
  [selection helpers](https://tidyselect.r-lib.org/reference/language.html)なども使える。
  動かさない列を `!` で反転指定するのほうが楽なことも多い。

`names_to`
: 元々列名だったものを入れる列の名前

`values_to`
: 値の移動先の列名

```{r, pivot-longer-anscombe}
anscombe_long = anscombe |>
  tibble::rowid_to_column("id") |>
  print() |>
  pivot_longer(!id, names_to = "namae", values_to = "atai") |>
  print()
```

### `tidyr::pivot_wider()` で横広にする

1列にまとまっていた値を、別の変数に応じて複数の列に並べ直すことで、
data.frameを縦長(long-format)から横広(wide-format)に変形する。
`reshape2::dcast()`, `tidyr::spread()` の改良版。

`tidyr::pivot_wider(data, ..., id_cols = NULL, names_from = name, values_from = value, values_fill = NULL, values_fn = NULL)`

`...`, `id_cols`
: ここで指定した列のユニークな組み合わせが変形後にそれぞれ1行になる。
  `!`で反転指定、`:`で範囲指定、文字列、tidyselect関数なども使える。
  デフォルトでは `names_from` と `values_from` で指定されなかった列すべて。

`names_from`
: 新しく列名になる列。"name" という列名なら省略可能。

`values_from`
: 動かしたい値が入っている列。"value" という列名なら省略可能。

`values_fill`
: 存在しない組み合わせのセルを埋める値。
  列によって値を変えたい場合は名前付きリストで渡す。

`values_fn`
: `id_cols` の組み合わせが一意に定まらず複数のvalueを1セルに詰め込む場合の処理関数。
  デフォルトでは警告とともに `list()` が使われる。


```{r, pivot-wider-anscombe}
anscombe_long |>
  pivot_wider(names_from = namae, values_from = atai) |>
  dplyr::select(!id)
```

カテゴリカル変数を指示変数(ダミー変数)に変換するのにも使える:

```{r, pivot-wider-plantgrowth}
pg = PlantGrowth |> dplyr::slice(c(1, 2, 11, 12, 21, 22)) |> print()
pg |> tibble::rowid_to_column("id") |>
  dplyr::mutate(name = group, value = 1L) |>
  tidyr::pivot_wider(values_fill = 0L) |>
  dplyr::select(!c(id, ctrl))
```


### `tidyr::pivot_*` 関数のもっと高度なオプション

`names_sep` や `names_pattern` を指定して
`names_to`, `name_from` に複数の値を渡すと
`tidyr::separate()` / `tidyr::unite()` 的な操作も同時にやってしまえる:

```{r, pivot-longer-names-sep}
#| results: "hold"
anscombe |> tibble::rowid_to_column("id") |>
  pivot_longer(!id, names_to = c("axis", "group"), names_sep = 1L) |>
  print() |>
  pivot_wider(id_cols = id, names_from = c(axis, group), names_sep = "_")
```

```{r, pivot-longer-vadeaths}
#| results: "hold"
VADeaths |>
  as.data.frame() |>
  print() |>
  rownames_to_column("age") |>
  pivot_longer(!age, names_to = c("region", "sex"), names_sep = " ", values_to = "death")
```

`names_transform` に関数を指定すると、
列名だったものに適用される。
例えば型変換に使える:

```{r, pivot-longer-names-transform}
anscombe |>
  tibble::rowid_to_column("id") |>
  tidyr::pivot_longer(!id,
    names_to = c("axis", "group"),
    names_sep = 1L,
    names_transform = list(group = as.integer)) |>
  tidyr::pivot_wider(id_cols = c(id, group), names_from = axis) |>
  dplyr::select(!id) |>
  dplyr::arrange(group)
```

`names_prefix` を使えば、列名の頭に共通して付いてた文字を消せる:

```{r, pivot-longer-names-prefix}
anscombe |>
  dplyr::select(starts_with("x")) |>
  pivot_longer(everything(), names_prefix = "x")
```

`names_to` に `".value"` という特殊な値を渡すことで、
旧列名から新しい列名が作られ、複数列への縦長変形を同時にできる。
また `names_to = c("name", NA)` のように不要な列を捨てることもできる。

```{r, pivot-longer-names-value}
tidy_anscombe = anscombe |>
  pivot_longer(                       # 縦長に変形したい
    everything(),                     # すべての列について
    names_to = c(".value", "group"),  # x, yを列名に、1, 2, 3をgroup列に
    names_sep = 1L,                   # 切る位置
    names_transform = list(group = as.integer)   # 型変換
  ) |>
  dplyr::arrange(group) |>            # グループごとに並べる
  print()                             # ggplotしたい形！
```

See https://speakerdeck.com/yutannihilation/tidyr-pivot?slide=67 for details.


## Nested data.frame --- 入れ子構造

https://tidyr.tidyverse.org/articles/nest.html

### `tidyr::nest(data, ..., .by = NULL, .key = NULL, .names_sep = NULL)`

data.frameをネストして(入れ子にして)、list of data.frames のカラムを作る。
内側のdata.frameに押し込むカラムを `...` に指定するか、
外側に残すカラムを `!` で反転指定する。

```{r, tidyr-nest}
diamonds |> nest(NEW_COLUMN = !cut) |> dplyr::arrange(cut)
```
```r
# equivalent to
diamonds |> nest(NEW_COLUMN = c(carat, color:z)) |> dplyr::arrange(cut)
diamonds |> nest(.by = cut, .key = "NEW_COLUMN") |> dplyr::arrange(cut)
diamonds |> dplyr::group_nest(cut, .key = "NEW_COLUMN")
diamonds |> dplyr::nest_by(cut, .key = "NEW_COLUMN") |> dplyr::ungroup()
```

`.key` を使う方法でそれを省略すると `data` という名前の列になる。

cf. [Hadley Wickham: Managing many models with R (YouTube)](https://www.youtube.com/watch?v=rz3_FDVt9eg)


### `tidyr::unnest(data, cols, ...)`

ネストされたdata.frameを展開してフラットにする。
list of data.framesだけでなく、list of vectorsとかでもよい。

ネストされた列が複数ある場合に曖昧なコードにならないよう
`cols` を明示的に指定することが求められる。

```r
diamonds |>
  nest(NEW_COLUMN = !cut) |>
  unnest(cols = NEW_COLUMN)
```

方向を明示する `tidyr::unnest_longer()`, `tidyr::unnest_wider()` もある。


## その他の便利関数

### `tidyr::separate()`

文字列カラムを任意のセパレータで複数カラムに分割。
`tidyr::unite()` の逆。
`reshape2::colsplit()` に相当。

`tidyr::separate(data, col, into, sep = "[^[:alnum:]]", remove = TRUE, convert = FALSE, extra = "warn", fill = "warn", ...)`

`col`
:   切り分けたい列の名前

`into`
:   切り分けたあとの新しい列名を文字列ベクタで

`sep = "[^[:alnum:]]"`
:   セパレータを正規表現で。デフォルトはあらゆる非アルファベット。
:   整数を渡すと位置で切れる。例えば `A4` を `1L` で切ると `A` と `4` に。

`remove = TRUE`
:   切り分ける前の列を取り除くかどうか

`convert = FALSE`
:   切り分け後の値の型変換を試みるか

`extra = "warn"`
:   列数が揃わないときにどうするか: `warn`, `drop`, `merge`

`fill = "warn"`
:   足りない場合にどっち側をNAで埋めるか: `warn`, `right`, `left`。
    つまり、文字を左詰めにするには`right`が正解(紛らわしい)。

```{r, separate-vadeaths}
#| results: "hold"
VADeaths |> as.data.frame() |>
  tibble::rownames_to_column("class") |>
  print() |>
  tidyr::separate(class, c("lbound", "ubound"), "-", convert = TRUE)
```

行方向に分割する `tidyr::separate_rows(data, ..., sep, convert)` もある。

`tidyr::extract(data, col, into, regex, ...)`
を使えば正規表現でもっと細かく指定できる。

名前の似てる `tidyr::extract_numeric(x)` は
文字列から数字部分をnumericとして抜き出す関数だったが今はdeprecatedなので、
新しい[`readr::parse_number()`]({{< relref "readr.md" >}})を使うべし。


### `tidyr::unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)`

複数カラムを結合して1列にする。
`tidyr::separate()` の逆。

`paste()` とか `stringr::str_c()` でも似たようなことができるけど
`na.rm = TRUE` の挙動が欲しいときに便利。

```{r, unite}
df = tibble(x = c("x", "x", NA), y = c("y", NA, "y"))
df |> tidyr::unite(z, c(x, y), sep = "_", remove = FALSE)
df |> tidyr::unite(z, c(x, y), sep = "_", remove = FALSE, na.rm = TRUE)
df |> dplyr::mutate(z = stringr::str_c(x, y, sep = "_"))
df |> dplyr::mutate(z = dplyr::coalesce(x, y))
```


### `tidyr::complete(data, ..., fill = list())`

指定した列の全ての組み合わせが登場するように、
指定しなかった列に欠損値`NA`(あるいは任意の値)を補完した行を挿入する。

```r
df |> complete(key1, key2, fill = list(val1 = 0, val2 = "-"))
```

### `tidyr::expand(data, ...)`

指定した列の全ての組み合わせが登場するような新しいdata.frameを作る。
全ての列を指定すれば`complete()`と同じ効果だが、
指定しなかった列が消えるという点では異なる。

`crossing(...)`はvectorを引数に取る亜種で、
tibble版`expand.grid(...)`のようなもの。

`nesting(...)`は存在するユニークな組み合わせのみ残す、
`nest(data, ...) |> dplyr::select(!data)`のショートカット。
この結果は`expand()`や`complete()`の引数としても使える。

数値vectorの補完には`full_seq(x, period, tol = 1e-6)`が便利。


### `tidyr::drop_na(data, ...)`

`complete()`の逆。
指定した列に`NA`が含まれてる行を削除する。
何も指定しなければ標準の `data[complete.cases(data),]` と同じ。

### `tidyr::replace_na()`

欠損値 `NA` を好きな値で置き換える。
これまでは `mutate(x = ifelse(is.na(x), 0, x))` のようにしてたところを

```r
df |> replace_na(list(x = 0, y = "unknown"))
```

逆に、特定の値を`NA`にしたい場合は
[`dplyr::na_if()`]({{< relref "dplyr.md" >}})


### `tidyr::fill()`

`NA` を、その列の直前の `NA` でない値で埋める。
えくせるでセルの結合とかやってしまって、
最初のセルにしか値が無いような場合に使うのかな？


## 関連書籍

<a href="https://www.amazon.co.jp/dp/4297121700?&linkCode=li3&tag=heavywatal-22&linkId=77762a4d0080a840ec5d94df9c0c5ceb&language=ja_JP&ref_=as_li_ss_il" target="_blank"><img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4297121700&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=heavywatal-22&language=ja_JP" ></a><img src="https://ir-jp.amazon-adsystem.com/e/ir?t=heavywatal-22&language=ja_JP&l=li3&o=9&a=4297121700" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<a href="https://www.amazon.co.jp/dp/1492097403?&linkCode=li3&tag=heavywatal-22&linkId=163b4c2d2d4f43d197e985a033d397c1&language=ja_JP&ref_=as_li_ss_il" target="_blank"><img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=1492097403&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=heavywatal-22&language=ja_JP" ></a><img src="https://ir-jp.amazon-adsystem.com/e/ir?t=heavywatal-22&language=ja_JP&l=li3&o=9&a=1492097403" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<a href="https://www.amazon.co.jp/dp/487311814X?&linkCode=li3&tag=heavywatal-22&linkId=a289b1f9dbb4f189b4209b374662d6f7&language=ja_JP&ref_=as_li_ss_il" target="_blank"><img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=487311814X&Format=_SL250_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=heavywatal-22&language=ja_JP" ></a><img src="https://ir-jp.amazon-adsystem.com/e/ir?t=heavywatal-22&language=ja_JP&l=li3&o=9&a=487311814X" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
